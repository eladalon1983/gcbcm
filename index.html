<!DOCTYPE html>
<html lang="en-us">
  <head>
    <meta content="text/html; charset=utf-8" http-equiv="Content-Type" />
    <title>getCurrentBrowsingContextMedia</title>
    <script class="remove" src="gcbcm.js" type="text/javascript"></script>
    <script src="https://www.w3.org/Tools/respec/respec-w3c" class="remove"></script>
  </head>
  <body>
    <section id="abstract">
      <p>
        This document proposes a variant of
        <a data-cite="SCREEN-CAPTURE#dom-mediadevices-getdisplaymedia">getDisplayMedia</a>.
      </p>
    </section>
    <section id="sotd"></section>
    <section id="conformance"></section>
    <section id="introduction">
      <h2>Introduction</h2>
      <p>
        This document presents <code>navigator.mediaDevices.getCurrentBrowsingContextMedia</code>.
      </p>
      <section>
        <h3>Background</h3>
        <section>
          <h4>getDisplayMedia</h4>
          <p>
            Consider
            <a data-cite="SCREEN-CAPTURE#dom-mediadevices-getdisplaymedia">getDisplayMedia</a>. It
            allows applications to prompt the user for permission to capture a
            <a data-cite="SCREEN-CAPTURE#dfn-display-surface">display surface</a>.
            <a data-cite="SCREEN-CAPTURE#">The document</a> specifying
            <a data-cite="SCREEN-CAPTURE#dom-mediadevices-getdisplaymedia">getDisplayMedia</a>
            mandates that the application must not be allowed to influence the user's selection.
            That part of the standard is the source of recurring debates.
          </p>
          <ul>
            <li>
              On the one hand, the principle is sound - what a legitimate application can control, a
              malicious application can abuse.
            </li>
            <li>
              On the other hand, user agents may present
              <a data-cite="SCREEN-CAPTURE#dfn-display-surface">display surfaces</a>
              in any order and still be spec-compliant. Even, that is, if the riskiest option is
              presented first.
            </li>
          </ul>
          <p>
            The riskiest option is the current <a data-cite="SCREEN-CAPTURE#dfn-monitor">screen</a>.
          </p>
          <ul>
            <li>
              Many users have only a single monitor. For them, sharing the current
              <a data-cite="SCREEN-CAPTURE#dfn-monitor">screen</a> amounts to sharing everything.
            </li>
            <li>
              The current <a data-cite="SCREEN-CAPTURE#dfn-browser">tab</a>, which is very risky by
              virtue of being under the application's control, is visible on the current
              <a data-cite="SCREEN-CAPTURE#dfn-monitor">screen</a> when capture starts. This means a
              malicious application can embed and capture cross-origin content, which sould normally
              be opaque. A single frame is sufficient for such attacks.
            </li>
          </ul>
        </section>
        <section>
          <h4><dfn>getViewportMedia</dfn></h4>
          <p>
            An API called [=getViewportMedia=] is currently being standardized. Some opinions differ
            with respect to the required security measures.
          </p>
          <ul>
            <li>
              Some WebRTC WG members position is that
              <a data-cite="HTML#dom-crossoriginisolated">cross-origin isolation</a> is needed, as
              well as a yet unspecified <code>opt-in header</code>. This ensures that embedded
              documents and sub-resources opt-in to being capturable, addressing the concern of a
              malicious document reading cross-origin content using [=getViewportMedia=].
            </li>
            <li>
              Other WebRTC WG members believe that mandating
              <a data-cite="HTML#dom-crossoriginisolated">cross-origin isolation</a> and a new
              <code>opt-in header</code> is one option, and that another option is for
              [=getViewportMedia=] to present a
              <a data-cite="SCREEN-CAPTURE#dom-mediadevices-getdisplaymedia">getDisplayMedia</a
              >-like dialog to the user, permitting the user to choose any
              <a data-cite="SCREEN-CAPTURE#dfn-display-surface">display surface</a>, but presenting
              the current <a data-cite="SCREEN-CAPTURE#dfn-browser">tab</a> as the first option. The
              rationale here is that if [=getViewportMedia=] is a variation of
              <a data-cite="SCREEN-CAPTURE#dom-mediadevices-getdisplaymedia">getDisplayMedia</a>
              that does poses no regression to privacy and security. (Note that this would comply
              with the standard's requirements for
              <a data-cite="SCREEN-CAPTURE#dom-mediadevices-getdisplaymedia">getDisplayMedia</a>.)
            </li>
          </ul>
          <p>
            One main concern over requiring
            <a data-cite="HTML#dom-crossoriginisolated">cross-origin isolation</a> and a new
            <code>opt-in header</code>, is that it sets a very high barrier to entry, which might
            hinder [=getViewportMedia=]'s adoption.
          </p>
        </section>
        <section>
          <h4>Conclusion</h4>
          <p>
            A variant of
            <a data-cite="SCREEN-CAPTURE#dom-mediadevices-getdisplaymedia">getDisplayMedia</a> that
            allows the user unconstrained
            <a data-cite="SCREEN-CAPTURE#dfn-display-surface">display surface</a> choice, but which
            orders <a data-cite="SCREEN-CAPTURE#dfn-display-surface">display surfaces</a> so that
            current <a data-cite="SCREEN-CAPTURE#dfn-monitor">screen</a> is NOT the first option,
            would be both spec-compliant as well as an improvement to user privacy and user
            security.
          </p>
          <p>
            If this variant presents the current
            <a data-cite="SCREEN-CAPTURE#dfn-browser">tab</a> as the first option, it will also be
            an alternative to [=getViewportMedia=] that can be called from a context lacking either
            <a data-cite="HTML#dom-crossoriginisolated">cross-origin isolation</a> or the opt-in
            header. (Recall that the current screen contains the current
            <a data-cite="SCREEN-CAPTURE#dfn-browser">tab</a>, and is therefore riskier.)
          </p>
          <p>We therefore propose {{MediaDevices/getCurrentBrowsingContextMedia}}.</p>
        </section>
      </section>
    </section>
    <section id="get-current-browsing-context-media">
      <h2>getCurrentBrowsingContextMedia</h2>
      <pre class="idl">
        partial interface MediaDevices {
          Promise&lt;MediaStream&gt; getCurrentBrowsingContextMedia(
              optional DisplayMediaStreamConstraints constraints = {});
        };
      </pre>
      <dl data-link-for="MediaDevices" data-dfn-for="MediaDevices" class="methods">
        <dt>
          <dfn>getCurrentBrowsingContextMedia</dfn>
        </dt>
        <dd>
          <p>
            When {{MediaDevices/getCurrentBrowsingContextMedia}} is invoked, the user agent MUST run
            through all of the steps of
            <a data-cite="SCREEN-CAPTURE#dom-mediadevices-getdisplaymedia">getDisplayMedia</a>, with
            one key difference - {{MediaDevices/getCurrentBrowsingContextMedia}} SHOULD present the
            current tab as the most prominent option, whereas
            <a data-cite="SCREEN-CAPTURE#dom-mediadevices-getdisplaymedia">getDisplayMedia</a> is
            not required to do so.
          </p>
          <p>
            Note: If [=getViewportMedia=] is extended in the future to accept additional parameters,
            {{MediaDevices/getCurrentBrowsingContextMedia}}'s specification will be updated to
            describe how {{MediaDevices/getCurrentBrowsingContextMedia}} should behave if given the
            same paramers. The intention is to provide similar functionality to [=getViewportMedia=]
            without requiring
            <a data-cite="HTML#dom-crossoriginisolated">cross-origin isolation</a> or the new
            <code>opt-in header</code>.
          </p>
        </dd>
      </dl>
    </section>
  </body>
</html>
